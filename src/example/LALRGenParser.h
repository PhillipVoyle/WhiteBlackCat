#pragma once

/*
   LALRGenParser.h, generated by wbcparse (c) Phillip Voyle 2005 - 2021.
*/

#include "LRToken.h"
#include "LALRGenParserTable.h"
#include <assert.h>

/*
   Type Definitions:
   wbcparse generates type defining classes for each
*/
template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tAdd>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tSub>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tMul>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tDiv>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tNumber>
{
public:
   typedef float storeClass;
   typedef float transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tLeftBracket>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tRightBracket>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::tEndLine>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::$>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::ntProgram>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::ntExpression>
{
public:
   typedef float storeClass;
   typedef float transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::ntLines>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::ntEvaluatedExpression>
{
public:
   typedef float storeClass;
   typedef float transClass;
};

template<>
template<>
class CLRToken<CLALRGenParserTable::TokenID>::TokenType<CLALRGenParserTable::ntLine>
{
public:
   typedef void storeClass;
   typedef void transClass;
};

template <class TBase>
class CLALRGenParser
   :public TBase
{
public:
   typedef CLALRGenParserTable::TokenID TokenID;
   typedef CLRToken<CLALRGenParserTable::TokenID> Token;
   typedef Token::TokenPtr TokenPtr;
private:
   typedef CLALRGenParserTable::ActionID ActionID;
   TokenPtr m_stack;
public:
   template<typename...TArgs>
   CLALRGenParser(TArgs...args):TBase(args...)
   {
      init();
   }
   bool reduce(int nReduce)
   {
      TokenPtr reduced;
      int nextState = -1;
      switch(nReduce)
      {
      case 0:
      {
         this->Accept();
         m_stack = TokenPtr();
         return false;
      }
      case 1:
      {
         m_stack = m_stack->GetNext();//pop ntLines
{}
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntProgram);
         reduced = Token::CreateToken_VOID<CLALRGenParserTable::ntProgram>();
         }
         break;
      case 2:
      {
         float $$;
{ $$ = this->expectedExpression(); }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 3:
      {
         float $$;
         float $3 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
         m_stack = m_stack->GetNext();//pop tAdd
         float $1 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
{ $$ = this->add($1, $3); }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 4:
      {
         float $$;
         float $3 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
         m_stack = m_stack->GetNext();//pop tSub
         float $1 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
{ $$ = this->sub($1, $3); }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 5:
      {
         float $$;
         float $3 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
         m_stack = m_stack->GetNext();//pop tMul
         float $1 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
{ $$ = this->mul($1, $3); }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 6:
      {
         float $$;
         float $3 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
         m_stack = m_stack->GetNext();//pop tDiv
         float $1 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
{ $$ = this->div($1, $3); }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 7:
      {
         float $$;
         float $1 = m_stack->GetData<CLALRGenParserTable::tNumber>();
         m_stack = m_stack->GetNext();//pop tNumber
{ $$ = $1; }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 8:
      {
         float $$;
         m_stack = m_stack->GetNext();//pop tRightBracket
         float $2 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
         m_stack = m_stack->GetNext();//pop tLeftBracket
{ $$ = $2; }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntExpression>($$);
         }
         break;
      case 9:
      {
         m_stack = m_stack->GetNext();//pop ntLines
         m_stack = m_stack->GetNext();//pop ntLine
{ }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntLines);
         reduced = Token::CreateToken_VOID<CLALRGenParserTable::ntLines>();
         }
         break;
      case 10:
      {
{}
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntLines);
         reduced = Token::CreateToken_VOID<CLALRGenParserTable::ntLines>();
         }
         break;
      case 11:
      {
         float $$;
         float $1 = m_stack->GetData<CLALRGenParserTable::ntExpression>();
         m_stack = m_stack->GetNext();//pop ntExpression
{ this->print($1); }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntEvaluatedExpression);
         reduced = Token::CreateToken<CLALRGenParserTable::ntEvaluatedExpression>($$);
         }
         break;
      case 12:
      {
         m_stack = m_stack->GetNext();//pop tEndLine
         float $1 = m_stack->GetData<CLALRGenParserTable::ntEvaluatedExpression>();
         m_stack = m_stack->GetNext();//pop ntEvaluatedExpression
{ }
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntLine);
         reduced = Token::CreateToken_VOID<CLALRGenParserTable::ntLine>();
         }
         break;
      case 13:
      {
         m_stack = m_stack->GetNext();//pop tEndLine
{ this->blankLine();}
         nextState = CLALRGenParserTable::GetGoto(m_stack->GetState(), CLALRGenParserTable::ntLine);
         reduced = Token::CreateToken_VOID<CLALRGenParserTable::ntLine>();
         }
         break;
      default:
         return false;
      }
      if(nextState == -1)
      {
         this->ParserError(reduced);
      }
      else
      {
         reduced->SetState(nextState);
         reduced->SetNext(m_stack);
         m_stack = reduced;
      }
      return true;
   }
   void perform_early_reductions()
   {
     int nEarlyReduce = 0;
     do
     {
        nEarlyReduce = CLALRGenParserTable::GetEarlyReduce(m_stack->GetState());
        if(nEarlyReduce < 1)
        {
           return;
        }
      }while(reduce(nEarlyReduce));
   }

   void init()
   {
      m_stack = Token::CreateToken_VOID<CLALRGenParserTable::$>(); //init stack with state 0.
      m_stack->SetState(0);
   }
   void step(TokenPtr ptr)
   {
      const TokenID token = ptr->GetTokenID();
      for(;;)
      {
         const CLALRGenParserTable::Action action = CLALRGenParserTable::GetAction(m_stack->GetState(), token);
         switch(action.first)
         {
         case CLALRGenParserTable::aShift:
            ptr->SetNext(m_stack);
            ptr->SetState(action.second);
            m_stack = ptr;
            perform_early_reductions();
            return;
         case CLALRGenParserTable::aReduce:
            {
               if(!reduce(action.second))
               {
                  return;
               }
            }
            break;
         case CLALRGenParserTable::aError:
         default:
            this->ParserError(ptr);
            return;
         }
      }
   }
};

